///--------------------------------------------------------------------------------------
/// @file	mr_case.h
/// @brief	Test case base class.
///
/// @author		Michael Roop
/// @date		2010
/// @version	1.0
///
/// Copyright 2010 Michael Roop
///--------------------------------------------------------------------------------------
#if !defined(CPP_TEST_FIXTURE_H)
#define CPP_TEST_FIXTURE_H

#include "mr_string.h"
#include "mr_sstream.h"
#include "mr_char.h"
#include "mr_testInfoObject.h"
#include "CppTestCase.h"

// temp
#include "mr_iostream.h"

#include <assert.h>


namespace CppTest {

class TestCaseHolder;

///--------------------------------------------------------------------------------------
///
///	@brief	base class of all test fixtures
///
/// This class encapsulates performance logging of each stage of the test.  As well, it
/// tracks the state and holds test information generated by the derived tests.
///
/// The test case object can be querried by the logger derived objects to assemble the 
/// information required.
///
/// Test cases are void methods registered with a unique name which is used to identify
/// and retrieve the test.  A description string is provided at register time.
///
/// There are three stages to a test case, the setup, the test, and the cleanup.
///
/// You can regiser startup and teardown methods which are executed before and after
/// each test case
///
/// You can also register Fixture startup and teardown methods which are executed once 
/// before any test case is executed and after the last test case is executed.
///--------------------------------------------------------------------------------------
class Fixture {

public:

	///// @brief	Status indicator for the test case.
	//typedef enum Status {
	//	ST_NONE,		///< No status. Default.
	//	ST_SUCCESS,		///< Test was successful.
	//	ST_FAIL_SETUP,	///< Test failed on setup.
	//	ST_FAIL_TEST,	///< Test failed.
	//	ST_FAIL_CLEANUP,///< Test failed on cleanup.
	//	ST_NOT_EXISTS,	///< Test with unique id does not exist.

	//	ST_FAIL_FIXTURE_SETUP,
	//	ST_FAIL_FIXTURE_TEARDOWN

	//} TestCaseStatus;


	/// @brief	Typdef of a class method pointer with no param and no return to clean up syntax. 
	typedef void (Fixture::*  fixture_method_ptr) (void);

public:

	/// @brief	Constructor
	///	@param	name	Name of the test case.
	///	@param	desc	Description of test case.
	Fixture(const mr_utils::mr_string& name, const mr_utils::mr_string& desc);


	/// @brief	Run the named test case contained in the fixture
	/// @param	name	The test case name
	/// @param	args	Arguments for the named test case
	void RunTest(const mr_utils::mr_string& name, const mr_test::TestArguments& args);


	/// @brief	Called when the fixture has had the last test case executed
	void ResetFixture();


	/// @brief	Query if the test fixture has the named test case
	/// @parm	name	The test case name
	bool HasTest(const mr_utils::mr_string& name);


	/// @brief	Retrieve a list of test case names from fixture
	// TODO - decide on name format.  Probably should be TestFixtureName.TestCaseName
	const std::vector<mr_utils::mr_string> GetTestNames();


	///// @brief	Retrieve uniquely indentifying test name.
	/////
	///// @return	The unique name of the test.
	//const mr_utils::mr_string& name() const;


	///// @brief	Retrieve test description.
	/////
	///// @return	The description of the test.
	//const mr_utils::mr_string& desc() const;


	///// @brief	Retrieve the test status in string format.
	/////
	///// @exception	throws an mr_exception if the status is not accounted
	/////				for.  This would be a programming error.
	///// @return	The status of the test.
	//mr_utils::mr_string status() const;


	///// @brief	Retrieve the test status in enum format.
	/////
	///// @return	The status of the test.
	//TestCaseStatus statusEnum() const;


	///// @brief	Retrieve the performance timing for the test setup.
	/////
	///// @return	The time in ms that the setup took.
	//long long setupTime() const;


	///// @brief	Retrieve the performance timing for the test.
	/////
	///// @return	The time in ms that the test took.
	//long long execTime() const;


	///// @brief	Retrieve the performance timing for the test cleanuup.
	/////
	///// @return	The time in ms that the cleanup took.
	//long long cleanupTime() const;


	/// @brief	Retrieve a copy of the currently executed test case
	Case& CurrentTestCase() const;

	///// @brief	Retrieve the message buffer.
	/////
	/////	Call to add messages from your tests. You would usualy use this to document
	/////	a failure condition. This is usually put out to the shorter summary logs.
	/////
	///// @return	The test message buffer.
	//mr_utils::mr_stringstream& getMsgBuffer();


	///// @brief	Retrieve the message buffer.
	/////
	/////	This contains the details of failures from the comparison macros. These are usually
	///// more detailed and are sent to a specific log.
	/////
	///// @return	The test message buffer.
	//mr_utils::mr_stringstream& getVerboseBuffer();


protected:
	//TestCaseStatus				m_status;			///< Status of the test case.

protected:

	/// @brief	Register a setup method to be executed once for the entire fixture
	/// @param	setup The setup method
	void RegisterFixtureSetup(fixture_method_ptr setup);


	/// @brief	Register a teardown method to be executed once for the entire fixture
	/// @param	teardown The teardown method
	void RegisterFixtureTeardown(fixture_method_ptr teardown);
	

	/// @brief	Register a setup method to be executed for each test in the fixture
	/// @param	setup The setup method
	void RegisterTestSetup(fixture_method_ptr setup);


	/// @brief	Register a teardown method to be executed for each test in the fixture
	/// @param	teardown The teardown method
	void RegisterTestTeardown(fixture_method_ptr teardown);


	/// @brief	Register a test to be executed when called by name
	/// @param	test	The test method pointer
	/// @param	name	The test name
	/// @param	description	The test description
	void RegisterTest(fixture_method_ptr test, const mr_utils::mr_string& name, const mr_utils::mr_string& description);


	///	@brief	Reset any data from previous test TODO - replace with current test.data
	void ResetTest();


	/// @brief	Retrieve test arguments for current test case.
	///
	/// @return	The arguments for the test case.
	const mr_test::TestArguments& CurrentArgs() const;

private:

	//mr_utils::mr_string			m_name;				///< Test name.
	//mr_utils::mr_string			m_desc;				///< Test description.
	mr_test::TestArguments		m_args;				///< Arguments for current Test Case.

	//mr_utils::mr_stringstream	m_buffer;			///< Short message buffer.
	//mr_utils::mr_stringstream	m_verboseBuffer;	///< Verbose message buffer.
	//long long					m_setupTime;		///< Setup time in ms.
	//long long					m_execTime;			///< Test time in ms.
	//long long					m_cleanupTime;		///< Cleanup time in ms.
	fixture_method_ptr			m_fixtureSetup;		///< setup method for the entire fixture
	fixture_method_ptr			m_fixtureTeardown;	///< teardown method for the entire fixture
	fixture_method_ptr			m_testSetup;		///< setup method for each test
	fixture_method_ptr			m_testTeardown;		///< teardown method for each test
	bool						m_isFixtureCalled;	///< Determines if a test has been called on the fixture yet
	std::vector<TestCaseHolder*> m_tests;			///< The list of test cases
	TestCaseHolder*				m_currentTestCase;	///< The currently executing test case holder

private:

	/// @brief	Wrapper function to wrap performance logging for various methods.
	/// @param	timeVal	A reference to hold the timing information.
	/// @param	funcPtr	A pointer to the function to time.
	///
	/// @return	true if the function timed is successful, otherwise false.
	void ExecStep(long long& timeVal, fixture_method_ptr funcPtr, Case::TestCaseStatus failStatus);


	/// @brief	Execute the Fixture setup 
	void ExecTestFixtureSetup();

	
	/// @brief	Protected default constructor to force use of regular constructor.
	Fixture() ;


	/// @brief	Protected copy constructor to force use of regular constructor.
	///
	/// @param	tc	The testCase used for construction.
	Fixture( const Fixture& tc );

};


class TestCaseHolder {

public:
	//mr_utils::mr_string			m_name;
	//mr_utils::mr_string			m_description;
	Fixture::fixture_method_ptr m_test;
	Case*						m_testData;


	TestCaseHolder(Fixture::fixture_method_ptr testPtr, const mr_utils::mr_string& name, const mr_utils::mr_string& description) :	
		m_test(testPtr),
		//m_name(name),
		//m_description(description),
		m_testData(new Case(name, description)) {
	}


	virtual ~TestCaseHolder() {
		if (this->m_testData != 0) {
			delete this->m_testData;
			this->m_testData = 0;
		}
	}


	void Reset() {
		assert(this->m_testData);
		this->m_testData->Reset();
	}


	Case CloneTestCase() {
		assert(this->m_testData);
		return *(this->m_testData);
	}

private:
	TestCaseHolder() {
	}

	TestCaseHolder& operator = (const TestCaseHolder&) {
	}

	TestCaseHolder(const TestCaseHolder&) {
	}


};




} // end namespace cppTest

#endif